#' Background correction
#'
#' Background correct Cy5/Cy3 signal of a Infinium HumanMethylation450 BeadChip.
#'
#' @param rg Cy5/Cy3 signal generated by \code{\link{read.rg}()}.
#' @param offset Number to add to background corrected signal (Default: 15).
#' @param verbose If \code{TRUE}, then status messages are printed during execution (Default: \code{FALSE}).
#' @return Background corrected Cy5/Cy3 signal by \code{\link[limma]{normexp.signal}}.
background.correct <- function(rg, offset=15, verbose=F) {
    stopifnot(is.rg(rg))

    probes <- meffil.probe.info()
    for (dye in names(rg)) {
        msg("background correction for dye =", dye, verbose=verbose)
        addresses <- probes$address[which(probes$target %in% c("M","U") & probes$dye == dye)]
        addresses <- intersect(addresses, rownames(rg[[dye]]))
        xf <- rg[[dye]][addresses,"Mean"]
        xf[which(xf <= 0)] <- 1

        addresses <- probes$address[which(probes$type == "control" & probes$dye == dye)]
        addresses <- intersect(addresses, rownames(rg[[dye]]))
        xc <- rg[[dye]][addresses,"Mean"]
        xc[which(xc <= 0)] <- 1

        addresses <- probes$address[which(probes$target == "OOB" & probes$dye == dye)]
        addresses <- intersect(addresses, rownames(rg[[dye]]))
        oob <- rg[[dye]][addresses,"Mean"]

        ests <- huber.safe(oob)
        mu <- ests$mu
        sigma <- log(ests$s)
        alpha <- log(max(huber.safe(xf)$mu - mu, 10))
        ## mu = robust median of the oob probes
        ## sigma = log(mad of the oob probes)
        ## alpha = log(robust median of meth/unmeth probes  -  robust median of oob probes)
        ## c(xf,xc) = c(meth/unmeth probes, control probes)
        ## bg <- c(xf,xc) background corrected
        bg <- limma::normexp.signal(as.numeric(c(mu,sigma,alpha)), c(xf,xc)) + offset

        rg[[dye]][c(names(xf), names(xc)), "Mean"] <- bg
    }
    rg
}

huber.safe <- function(x) {
    ret <- tryCatch(MASS::huber(x), error=function(e) e)
    if ("error" %in% class(ret)) 
        ret <- tryCatch(MASS::huber(x[which(x > min(x,na.rm=T))]), error=function(e) stop(e))
    ret
}
